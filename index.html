<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Visor de Incendios - Resumen de Riesgo</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"
/>
<style>
  body, html {
    margin:0; padding:0; height:100%;
    font-family: Arial, sans-serif;
  }
  #map { height: 60vh; }
  #summary {
    padding: 10px;
    max-height: 35vh;
    overflow-y: auto;
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  table, th, td {
    border: 1px solid #666;
  }
  th, td {
    padding: 6px;
    text-align: center;
  }
  th {
    background: #004466;
    color: white;
  }
</style>
</head>
<body>
<h2 style="text-align:center; margin:10px;">Visor de Incendios Urbanos 2022</h2>
<div id="map"></div>
<div id="summary"><em>Dibuja un círculo para ver el resumen de riesgos dentro del área.</em></div>

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
></script>
<script
  src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"
></script>

<script>
// Inicializar mapa centrado en CDMX
const map = L.map("map").setView([19.43, -99.13], 11);

// Agregar capa base OSM
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
  attribution: "© OpenStreetMap"
}).addTo(map);

// Cargar GeoJSON (puedes poner tu ruta correcta)
const geojsonURL = "Incendios Urbanos 2022.geojson";

let incidentsLayer;
let incidentFeatures = [];

fetch(geojsonURL)
  .then(res => res.json())
  .then(data => {
    incidentFeatures = data.features;
    incidentsLayer = L.geoJSON(data, {
      pointToLayer: (feature, latlng) => {
        return L.circleMarker(latlng, {
          radius: 6,
          fillColor: "#ff7800",
          color: "#000",
          weight: 1,
          opacity: 1,
          fillOpacity: 0.8
        }).bindPopup(
          `<b>Incidente:</b> ${feature.properties.incidente_c4}<br/>
           <b>Alcaldía:</b> ${feature.properties.alcaldia_cierre}<br/>
           <b>Colonia:</b> ${feature.properties.colonia_cierre}`
        );
      }
    }).addTo(map);
  });

// Añadir control de dibujo
const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const drawControl = new L.Control.Draw({
  draw: {
    polygon: false,
    polyline: false,
    rectangle: false,
    marker: false,
    circlemarker: false,
    circle: {
      shapeOptions: {
        color: "#3388ff"
      },
      metric: true,
      repeatMode: false
    }
  },
  edit: {
    featureGroup: drawnItems,
    remove: true
  }
});
map.addControl(drawControl);

// Función para calcular niveles según cantidad
function calcularNivel(cantidad) {
  if (cantidad > 100) return "Alto";
  if (cantidad > 30) return "Medio";
  if (cantidad > 0) return "Bajo";
  return "Ninguno";
}

// Función para generar resumen de riesgo
function generarResumen(conteos) {
  const resumen = [];
  for (const amenaza in conteos) {
    const cantidad = conteos[amenaza];
    const probabilidad = calcularNivel(cantidad);
    const impacto = probabilidad; // simplificado, puede ajustarse
    const riesgo = probabilidad;  // simplificado, puede ajustarse
    const accionPreventiva = {
      "Incendios forestales":
        "Vigilancia constante, capacitación de brigadas, campañas de prevención y regulación de quemas.",
      "Quema de basura":
        "Promover la gestión adecuada de residuos y sancionar quemas irresponsables.",
      "Casa habitacion":
        "Mejorar medidas de prevención contra incendios domiciliarios.",
      "Vehiculo":
        "Inspección y control de riesgos en vehículos.",
      "Arbol":
        "Monitoreo y manejo adecuado de vegetación.",
      "Industria":
        "Regulación y supervisión de instalaciones industriales.",
      "Edificio":
        "Implementar protocolos de seguridad en edificaciones.",
      "Negocio plaza comercial mercado":
        "Capacitación y controles en establecimientos comerciales."
    }[amenaza] || "Implementar acciones preventivas específicas para esta amenaza.";

    resumen.push({
      amenaza,
      probabilidad,
      impacto,
      riesgo,
      accionPreventiva
    });
  }
  return resumen;
}

// Función para mostrar tabla resumen en el div #summary
function mostrarResumen(resumen) {
  if (resumen.length === 0) {
    document.getElementById("summary").innerHTML = "<em>No hay incidentes dentro del área seleccionada.</em>";
    return;
  }
  let html = `<table><thead><tr>
    <th>Amenaza</th><th>Probabilidad</th><th>Impacto</th><th>Riesgo</th><th>Acción Preventiva</th>
  </tr></thead><tbody>`;
  resumen.forEach(r => {
    html += `<tr>
      <td>${r.amenaza}</td>
      <td>${r.probabilidad}</td>
      <td>${r.impacto}</td>
      <td>${r.riesgo}</td>
      <td style="text-align:left;">${r.accionPreventiva}</td>
    </tr>`;
  });
  html += "</tbody></table>";
  document.getElementById("summary").innerHTML = html;
}

// Evento cuando se crea un dibujo
map.on(L.Draw.Event.CREATED, e => {
  drawnItems.clearLayers();
  const layer = e.layer;
  drawnItems.addLayer(layer);

  const center = layer.getLatLng();
  const radius = layer.getRadius();

  // Filtrar incidentes dentro del círculo
  const dentro = incidentFeatures.filter(f => {
    const coords = f.geometry.coordinates; // [long, lat]
    const latlng = L.latLng(coords[1], coords[0]);
    return latlng.distanceTo(center) <= radius;
  });

  // Contar por tipo de incidente
  const conteos = {};
  dentro.forEach(f => {
    const tipo = f.properties.incidente_c4 || "Desconocido";
    conteos[tipo] = (conteos[tipo] || 0) + 1;
  });

  // Generar resumen y mostrarlo
  const resumen = generarResumen(conteos);
  mostrarResumen(resumen);
});
</script>
</body>
</html>
